/*
 * Copyright (c) 2022, Uppsala universitet.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the Institute nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * This file is part of the Contiki operating system.
 *
 */

/**
 * \file
 *         Demonstrates the usage of FHMQV.
 * \author
 *         Konrad Krentz <konrad.krentz@gmail.com>
 */

#include "contiki.h"
#include "lib/ecc.h"
#include "lib/sha-256.h"
#include <string.h>

#include "sys/log.h"
#define LOG_MODULE "FHMQV"
#define LOG_LEVEL LOG_LEVEL_DBG

PROCESS(fhmqv_process, "FHMQV");
AUTOSTART_PROCESSES(&fhmqv_process);

/*---------------------------------------------------------------------------*/
PROCESS_THREAD(fhmqv_process, ev, data)
{
  int result;
  static const uint8_t spkA[ECC_BYTES * 2] = {
      0x88 , 0xe8 , 0x8b , 0x83 , 0x29 , 0xba , 0x4c , 0x31 ,
      0x8b , 0xb7 , 0x46 , 0xc6 , 0x35 , 0xa3 , 0xba , 0xf0 ,
      0x8b , 0xcb , 0x2b , 0xaf , 0x9e , 0xa6 , 0x71 , 0x01 ,
      0xde , 0x41 , 0x6d , 0xb2 , 0x61 , 0x68 , 0x9c , 0xa9 ,
      0x47 , 0xb9 , 0x27 , 0xc2 , 0x2b , 0x5e , 0x2c , 0x3f ,
      0x1a , 0x91 , 0x00 , 0xf5 , 0x41 , 0xb3 , 0x3a , 0xf3 ,
      0xfd , 0x22 , 0xf6 , 0x7f , 0x1d , 0xb8 , 0x29 , 0x8a ,
      0xb3 , 0xf2 , 0xc8 , 0xa8 , 0xc5 , 0xf6 , 0x9e , 0x6d
  };
  static const uint8_t sskA[ECC_BYTES] = {
      0xc4 , 0x20 , 0x1d , 0xa9 , 0xc3 , 0x64 , 0xad , 0x83 ,
      0xa4 , 0xdb , 0x99 , 0x78 , 0xf1 , 0x7b , 0x27 , 0x02 ,
      0x4a , 0x9b , 0xf0 , 0xf1 , 0xb0 , 0x1b , 0x2c , 0x6b ,
      0xe7 , 0x20 , 0xc0 , 0x91 , 0x0c , 0x74 , 0x2e , 0xd1
  };
  static const uint8_t epkA[ECC_BYTES * 2] = {
      0xba , 0x63 , 0x3d , 0x72 , 0x3e , 0x0e , 0x86 , 0xd5 ,
      0x18 , 0x94 , 0x67 , 0x81 , 0xdd , 0xeb , 0x10 , 0xe1 ,
      0xce , 0xf5 , 0xf2 , 0x0b , 0xbf , 0xb2 , 0xb1 , 0x9f ,
      0xf6 , 0x1a , 0x3a , 0x8d , 0xe1 , 0x85 , 0x01 , 0xc4 ,
      0xd9 , 0x91 , 0x68 , 0x0b , 0x1b , 0xc4 , 0x84 , 0x15 ,
      0x95 , 0x9a , 0xdc , 0x96 , 0xac , 0x8e , 0xd0 , 0x36 ,
      0x7e , 0x88 , 0x46 , 0x59 , 0xf6 , 0xce , 0x9c , 0x7f ,
      0x4a , 0x29 , 0x9c , 0x37 , 0xff , 0x90 , 0xca , 0x6a
  };
  static const uint8_t eskA[ECC_BYTES] = {
      0x4f , 0xdb , 0xfd , 0x17 , 0xed , 0x73 , 0x62 , 0xc1 ,
      0x25 , 0x04 , 0x35 , 0x88 , 0x55 , 0x4f , 0x74 , 0x8a ,
      0x0d , 0xe8 , 0xcb , 0x74 , 0x81 , 0x16 , 0x6d , 0x21 ,
      0x61 , 0x3b , 0x42 , 0x14 , 0xdd , 0xc6 , 0x31 , 0x5a
  };
  static const uint8_t spkB[ECC_BYTES * 2] = {
      0x45 , 0xce , 0x64 , 0x93 , 0x5c , 0x6b , 0xbd , 0x7c ,
      0x5b , 0xe8 , 0xb6 , 0x05 , 0xb0 , 0xaa , 0xff , 0xb7 ,
      0xcc , 0xf8 , 0x4c , 0x9d , 0x43 , 0x6d , 0xa3 , 0x0e ,
      0x00 , 0x76 , 0x00 , 0x7d , 0xc1 , 0xe5 , 0xfb , 0x01 ,
      0x53 , 0xfd , 0xff , 0x8e , 0x92 , 0xff , 0xbb , 0x48 ,
      0x06 , 0x4d , 0x1b , 0xd7 , 0xbc , 0xe3 , 0x0c , 0x39 ,
      0xaf , 0x53 , 0xc5 , 0xd1 , 0x73 , 0xb1 , 0xd7 , 0x02 ,
      0xa1 , 0x55 , 0x85 , 0x41 , 0xdc , 0x2d , 0x86 , 0x1c
  };
  static const uint8_t sskB[ECC_BYTES] = {
      0x9d , 0xfa , 0xca , 0x36 , 0xa2 , 0x17 , 0x37 , 0x50 ,
      0xcf , 0xf5 , 0xc9 , 0x77 , 0x65 , 0x60 , 0x63 , 0x78 ,
      0x18 , 0xdb , 0x99 , 0xd5 , 0x7a , 0x29 , 0x3e , 0x66 ,
      0xa1 , 0x3d , 0x3f , 0x52 , 0xbe , 0x08 , 0xfb , 0x54
  };
  static const uint8_t epkB[ECC_BYTES * 2] = {
      0x8f , 0xa8 , 0xa3 , 0x43 , 0xa6 , 0x0b , 0x04 , 0x3d ,
      0x5f , 0x4c , 0x03 , 0xfa , 0x74 , 0x1b , 0xe6 , 0xaf ,
      0x48 , 0xbb , 0xfd , 0x5c , 0x0e , 0xf5 , 0x3e , 0x7e ,
      0x27 , 0x3c , 0xa7 , 0x2c , 0x7b , 0x93 , 0xd4 , 0x0e ,
      0x09 , 0x60 , 0x56 , 0x9d , 0x77 , 0xa6 , 0xbd , 0x63 ,
      0x75 , 0xb7 , 0xba , 0xf5 , 0x85 , 0xdc , 0xa8 , 0x6d ,
      0x86 , 0x89 , 0xce , 0xcf , 0x59 , 0x9f , 0x39 , 0x38 ,
      0x1b , 0xbf , 0x07 , 0xe6 , 0x6d , 0x5a , 0x1d , 0xf8
  };
  static const uint8_t eskB[ECC_BYTES] = {
      0x7f , 0xe3 , 0xe4 , 0x86 , 0xe2 , 0x3a , 0xdb , 0xaf ,
      0x7c , 0xd4 , 0x71 , 0x94 , 0x2f , 0xa0 , 0xbc , 0x5f ,
      0x38 , 0xf8 , 0x92 , 0xb7 , 0x1a , 0x11 , 0x1b , 0xcf ,
      0x91 , 0x60 , 0x63 , 0xc5 , 0x41 , 0xa1 , 0x23 , 0x6f
  };
  static uint8_t d[SHA_256_DIGEST_LENGTH];
  static uint8_t e[SHA_256_DIGEST_LENGTH];
  static uint8_t kA[ECC_BYTES];
  static uint8_t kB[ECC_BYTES];

  PROCESS_BEGIN();

  LOG_INFO("Running FHMQV\n");
  ECC.enable();

  /* d || e */
  SHA_256.init();
  SHA_256.update(epkA, sizeof(epkA));
  SHA_256.update(epkB, sizeof(epkB));
  SHA_256.update(spkA, sizeof(spkA));
  SHA_256.update(spkB, sizeof(spkB));
  SHA_256.finalize(d);
  memcpy(e + SHA_256_DIGEST_LENGTH / 2, d, SHA_256_DIGEST_LENGTH / 2);
  memset(e, 0, SHA_256_DIGEST_LENGTH / 2);
  memset(d, 0, SHA_256_DIGEST_LENGTH / 2);

  PROCESS_PT_SPAWN(ECC.get_protothread(),
      ECC.generate_fhmqv_secret(kB, sskB, eskB, spkA, epkA, e, d, &result));
  if(result) {
    LOG_ERR("ECC.generate_fhmqv_secret failed\n");
    PROCESS_EXIT();
  }

  PROCESS_PT_SPAWN(ECC.get_protothread(),
      ECC.generate_fhmqv_secret(kA, sskA, eskA, spkB, epkB, d, e, &result));
  if(result) {
    LOG_ERR("ECC.generate_fhmqv_secret failed\n");
    PROCESS_EXIT();
  }

  if(memcmp(kB, kA, ECC_BYTES)) {
    LOG_ERR("unequal\n");
  } else {
    LOG_INFO("OK\n");
  }

  PROCESS_END();
}
/*---------------------------------------------------------------------------*/
